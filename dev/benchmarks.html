<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Benchmarks · Supposition.jl Documentation</title><meta name="title" content="Benchmarks · Supposition.jl Documentation"/><meta property="og:title" content="Benchmarks · Supposition.jl Documentation"/><meta property="twitter:title" content="Benchmarks · Supposition.jl Documentation"/><meta name="description" content="Documentation for Supposition.jl Documentation."/><meta property="og:description" content="Documentation for Supposition.jl Documentation."/><meta property="twitter:description" content="Documentation for Supposition.jl Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Supposition.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Main Page</a></li><li><a class="tocitem" href="intro.html">Introduction to PBT</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="Examples/basic.html">Basic Usage</a></li><li><a class="tocitem" href="Examples/composition.html">Composing Generators</a></li><li><a class="tocitem" href="Examples/recursive.html">Recursive Generation</a></li><li><a class="tocitem" href="Examples/docalignment.html">Alignment of Documentation</a></li><li><a class="tocitem" href="Examples/target.html">Targeted Operation</a></li><li><a class="tocitem" href="Examples/stateful.html">Stateful Testing</a></li><li><a class="tocitem" href="Examples/events.html">Events &amp; Oracle testing</a></li></ul></li><li><a class="tocitem" href="resources.html">PBT Resources</a></li><li><a class="tocitem" href="faq.html">FAQ</a></li><li><a class="tocitem" href="interfaces.html">Userfacing API</a></li><li class="is-active"><a class="tocitem" href="benchmarks.html">Benchmarks</a><ul class="internal"><li><a class="tocitem" href="#Generation"><span>Generation</span></a></li><li><a class="tocitem" href="#Shrinking"><span>Shrinking</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li><li><a class="tocitem" href="api.html">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="benchmarks.html">Benchmarks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="benchmarks.html">Benchmarks</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Seelengrab/Supposition.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Seelengrab/Supposition.jl/blob/main/docs/src/benchmarks.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h1><p>Since Julia developers can sometimes go crazy for performance and because PropCheck.jl already had a bunch of optimizations to (or try to, as we&#39;ll see) make it go fast, let&#39;s compare it to Supposition.jl to see how the two stack up against each other. Since both packages have been written by the same author, I think I&#39;m in the clear and won&#39;t step on anyones feet :)</p><p>All benchmarks were run on the same machine, with the same Julia version:</p><pre><code class="language-julia-repl hljs">julia&gt; versioninfo()
Julia Version 1.12.0-DEV.89
Commit 35cb8a556b (2024-02-27 06:12 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: 24 × AMD Ryzen 9 7900X 12-Core Processor
  WORD_SIZE: 64
  LLVM: libLLVM-16.0.6 (ORCJIT, znver4)
Threads: 23 default, 1 interactive, 11 GC (on 24 virtual cores)
Environment:
  JULIA_PKG_USE_CLI_GIT = true</code></pre><h2 id="Generation"><a class="docs-heading-anchor" href="#Generation">Generation</a><a id="Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Generation" title="Permalink"></a></h2><h3 id="Integers"><a class="docs-heading-anchor" href="#Integers">Integers</a><a id="Integers-1"></a><a class="docs-heading-anchor-permalink" href="#Integers" title="Permalink"></a></h3><p>The task is simple - generating a single <code>Vector{Int}</code> with <code>1_000_000</code> elements, through the respective interface of each package.</p><p>First, PropCheck.jl:</p><pre><code class="language-julia-repl hljs">julia&gt; using BenchmarkTools

julia&gt; using PropCheck

julia&gt; intgen = PropCheck.vector(PropCheck.iconst(1_000_000), itype(Int));

julia&gt; @benchmark root(PropCheck.generate(intgen))
BenchmarkTools.Trial: 1 sample with 1 evaluation.
 Single result which took 5.780 s (30.71% GC) to evaluate,
 with a memory estimate of 9.17 GiB, over 27285108 allocations.</code></pre><p>And now, Supposition:</p><pre><code class="language-julia-repl hljs">julia&gt; using BenchmarkTools

julia&gt; using Supposition

julia&gt; intgen = Data.Vectors(Data.Integers{Int}(); min_size=1_000_000, max_size=1_000_000);

julia&gt; @benchmark example($intgen)
BenchmarkTools.Trial: 646 samples with 1 evaluation.
 Range (min … max):  5.556 ms … 24.662 ms  ┊ GC (min … max):  0.00% … 72.10%
 Time  (median):     6.344 ms              ┊ GC (median):     4.18%
 Time  (mean ± σ):   7.734 ms ±  4.033 ms  ┊ GC (mean ± σ):  19.81% ± 19.08%

  █▇▅▄▅▅▅▂
  █████████▆▅▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▅█▇▆█▆▄▁▁▁▄▅▁▆▆▆▆▆▄▄▆ ▇
  5.56 ms      Histogram: log(frequency) by time     22.7 ms &lt;

 Memory estimate: 25.04 MiB, allocs estimate: 34.</code></pre><p>GC percentage is about the same, but the used memory and total number of allocations are VASTLY in favor of Supposition.jl, by about a factor of ~1000 timewise and a factor 300 memorywise.</p><p>To put this into perspective, here&#39;s a benchmark of just <code>1_000_000</code> <code>Int</code> randomly generated:</p><pre><code class="language-julia-repl hljs">julia&gt; @benchmark rand(Int, 1_000_000)
BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min … max):  182.570 μs …  11.340 ms  ┊ GC (min … max):  0.00% … 96.50%
 Time  (median):     311.934 μs               ┊ GC (median):     0.00%
 Time  (mean ± σ):   391.653 μs ± 244.852 μs  ┊ GC (mean ± σ):  11.15% ± 15.24%

      ▆██▆▆▆▅▄▃▂▁▁▁▁            ▁▁▂▂▂▁▁                         ▂
  ▄▆▇████████████████████▇▇▇▇▆▅▇█████████▇▇▇█▇▇▆▅▅▄▄▄▄▃▄▅▄▃▄▄▄▅ █
  183 μs        Histogram: log(frequency) by time       1.33 ms &lt;

 Memory estimate: 7.63 MiB, allocs estimate: 3.</code></pre><p>So Supposition.jl is within 300x of just generating some random numbers, suggesting there&#39;s still room for improvement.</p><h3 id="Floats"><a class="docs-heading-anchor" href="#Floats">Floats</a><a id="Floats-1"></a><a class="docs-heading-anchor-permalink" href="#Floats" title="Permalink"></a></h3><p>This is basically the same task as with <code>Int</code>, just producing <code>1_000_000</code> <code>Float64</code> instead.</p><p>We&#39;ll start with PropCheck.jl again:</p><pre><code class="language-julia-repl hljs">julia&gt; floatgen = PropCheck.vector(PropCheck.iconst(1_000_000), PropCheck.ifloatinfnan(Float64));

julia&gt; @benchmark root(PropCheck.generate(floatgen))
BenchmarkTools.Trial: 2 samples with 1 evaluation.
 Range (min … max):  4.524 s …    4.677 s  ┊ GC (min … max): 24.68% … 25.56%
 Time  (median):     4.600 s               ┊ GC (median):    25.13%
 Time  (mean ± σ):   4.600 s ± 108.561 ms  ┊ GC (mean ± σ):  25.13% ±  0.63%

  █                                                        █
  █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁
  4.52 s         Histogram: frequency by time         4.68 s &lt;

 Memory estimate: 4.64 GiB, allocs estimate: 18364056.</code></pre><p>And again, with Supposition.jl:</p><pre><code class="language-julia-repl hljs">julia&gt; floatgen = Data.Vectors(Data.Floats{Float64}(); min_size=1_000_000, max_size=1_000_000);

julia&gt; @benchmark example($floatgen)
BenchmarkTools.Trial: 736 samples with 1 evaluation.
 Range (min … max):  5.547 ms …  22.696 ms  ┊ GC (min … max): 0.00% … 75.37%
 Time  (median):     6.720 ms               ┊ GC (median):    5.02%
 Time  (mean ± σ):   6.793 ms ± 993.344 μs  ┊ GC (mean ± σ):  6.67% ±  4.56%

                ▂▂▂▆▁▅▃▄▃▂▃█▄▂▂▅▂▇▄ ▆ ▁▃▃▂▁▃▁▁    ▁
  ▃▁▂▂▁▁▃▃▃▂▄▄▇▅██████████████████████████████▇▅▇▅██▇▄▃▃▃▃▂▂▃ ▅
  5.55 ms         Histogram: frequency by time        7.88 ms &lt;

 Memory estimate: 25.04 MiB, allocs estimate: 34.</code></pre><p>Once again, Supposition.jl beats PropCheck.jl by a factor of 500+ in time and a factor of 100 in memory.</p><h3 id="Strings"><a class="docs-heading-anchor" href="#Strings">Strings</a><a id="Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Strings" title="Permalink"></a></h3><p>Both Supposition.jl and PropCheck.jl can generate the full spectrum of possible <code>String</code>, by going through <em>all</em> assigned unicode codepoints using specialized generation methods. Let&#39;s compare them, starting again with PropCheck.jl:</p><pre><code class="language-julia-repl hljs"># the default uses all valid `Char`
julia&gt; strgen = PropCheck.str(PropCheck.iconst(1_000_000));

julia&gt; @benchmark root(PropCheck.generate(strgen))
BenchmarkTools.Trial: 9 samples with 1 evaluation.
 Range (min … max):  458.354 ms … 631.947 ms  ┊ GC (min … max): 24.95% … 46.11%
 Time  (median):     572.739 ms               ┊ GC (median):    39.24%
 Time  (mean ± σ):   559.611 ms ±  55.519 ms  ┊ GC (mean ± σ):  38.24% ±  6.11%

  █                   █   █ █             ██     █         █  █
  █▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁█▁█▁▁▁▁▁▁▁▁▁▁▁▁▁██▁▁▁▁▁█▁▁▁▁▁▁▁▁▁█▁▁█ ▁
  458 ms           Histogram: frequency by time          632 ms &lt;

 Memory estimate: 1.01 GiB, allocs estimate: 4999798.</code></pre><p>PropCheck.jl manages to go below 1s runtime for the first time! It still doesn&#39;t manage to use less than 1GiB of memory though. Supposition.jl on the other hand..</p><pre><code class="language-julia-repl hljs">julia&gt; strgen = Data.Text(Data.Characters(); min_len=1_000_000, max_len=1_000_000);

julia&gt; @benchmark example($strgen)
BenchmarkTools.Trial: 163 samples with 1 evaluation.
 Range (min … max):  26.756 ms … 62.461 ms  ┊ GC (min … max): 0.00% … 48.46%
 Time  (median):     28.386 ms              ┊ GC (median):    1.95%
 Time  (mean ± σ):   30.679 ms ±  6.679 ms  ┊ GC (mean ± σ):  8.86% ± 12.41%

  ▄██▅▃
  █████▆█▆▃▁▂▁▁▁▁▁▁▁▁▁▁▁▁▁▂▁▃▁▄▂▃▂▂▁▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄ ▂
  26.8 ms         Histogram: frequency by time        56.9 ms &lt;

 Memory estimate: 30.22 MiB, allocs estimate: 66.</code></pre><p>..completely obliterates PropCheck.jl yet again, being only barely slower than generating one million <code>Int</code> or <code>Float64</code>. To put this into perspective, bare <code>randstring</code> is faster by a factor of only ~3:</p><pre><code class="language-julia-repl hljs">julia&gt; using Random

julia&gt; @benchmark randstring(typemin(Char):&quot;\xf7\xbf\xbf\xbf&quot;[1], 1_000_000)
BenchmarkTools.Trial: 675 samples with 1 evaluation.
 Range (min … max):  6.920 ms …   9.274 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     7.055 ms               ┊ GC (median):    0.00%
 Time  (mean ± σ):   7.221 ms ± 366.592 μs  ┊ GC (mean ± σ):  2.22% ± 3.98%

   ▅█▅▃▁
  ▄█████▇▇▅▃▃▃▃▃▃▂▃▂▁▃▂▂▂▃▃▄▃▃▄▂▃▃▃▃▂▃▃▂▂▂▂▂▂▃▂▂▂▂▂▂▂▁▁▁▂▁▁▂▂ ▃
  6.92 ms         Histogram: frequency by time         8.5 ms &lt;

 Memory estimate: 7.60 MiB, allocs estimate: 4.</code></pre><p>Considering the amount of state that is being kept track of here, I&#39;d say this is not too shabby.</p><h3 id="Map"><a class="docs-heading-anchor" href="#Map">Map</a><a id="Map-1"></a><a class="docs-heading-anchor-permalink" href="#Map" title="Permalink"></a></h3><p>Next, function mapping - which is one of the most basic tools to transform an input into something else. Our mapped function is the humble &quot;make even&quot; function, <code>x -&gt; 2x</code>. With PropCheck.jl:</p><pre><code class="language-julia-repl hljs">julia&gt; evengen = PropCheck.vector(PropCheck.iconst(1_000_000), PropCheck.map(x -&gt; 2x, PropCheck.itype(Int)));

julia&gt; @benchmark root(PropCheck.generate(evengen))
BenchmarkTools.Trial: 1 sample with 1 evaluation.
 Single result which took 7.554 s (26.22% GC) to evaluate,
 with a memory estimate of 9.32 GiB, over 32284641 allocations.</code></pre><p>and Supposition.jl:</p><pre><code class="language-julia-repl hljs">julia&gt; evengen = Data.Vectors(map(x -&gt; 2x, Data.Integers{Int}()); min_size=1_000_000, max_size=1_000_000);

julia&gt; @benchmark example($evengen, 1)
BenchmarkTools.Trial: 724 samples with 1 evaluation.
 Range (min … max):  5.444 ms … 34.544 ms  ┊ GC (min … max):  0.00% … 82.94%
 Time  (median):     5.900 ms              ┊ GC (median):     3.80%
 Time  (mean ± σ):   6.905 ms ±  3.775 ms  ┊ GC (mean ± σ):  16.51% ± 16.42%

  ▅█▅▄▁
  █████▄▅▅▅▄▅▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▅▆▅▆▅▄▅▁▅▁▅▅▆▆▅ ▇
  5.44 ms      Histogram: log(frequency) by time     21.7 ms &lt;

 Memory estimate: 25.04 MiB, allocs estimate: 36.</code></pre><p>And once again, Supposition.jl is victorious on all accounts.</p><h3 id="Filtering"><a class="docs-heading-anchor" href="#Filtering">Filtering</a><a id="Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering" title="Permalink"></a></h3><p>Benchmarking <code>filter</code> is a bit special now - Supposition.jl tries to protect you from too-long sampling sessions, which PropCheck.jl just doesn&#39;t even try. As a result, if we naively try to filter for even numbers with PropCheck, we get a monstrosity:</p><pre><code class="language-julia-repl hljs">julia&gt; evengen = PropCheck.vector(PropCheck.iconst(1_000_000), PropCheck.filter(iseven, PropCheck.itype(Int)));

julia&gt; @benchmark root(PropCheck.generate(evengen))
BenchmarkTools.Trial: 1 sample with 1 evaluation.
 Single result which took 37.428 s (24.58% GC) to evaluate,
 with a memory estimate of 50.67 GiB, over 220777721 allocations.</code></pre><p>37s and 50GiB memory used is a very tall order (especially for just a single vector!), and should rightly be kindly asked to leave the venue. Supposition.jl on the other hand stops you in your tracks:</p><pre><code class="language-julia-repl hljs">julia&gt; evengen = Data.Vectors(filter(iseven, Data.Integers{Int}()); min_size=1_000_000, max_size=1_000_000);

julia&gt; @benchmark example($evengen)
ERROR: Tried sampling 100000 times, without getting a result. Perhaps you&#39;re filtering out too many examples?</code></pre><p>and asks you what you&#39;re even doing. After all, make <code>1_000_000</code> coin flips and you&#39;re vanishingly unlikely to actually get a full vector with <code>1_000_000</code> elements that are all even (somewhere on the order of 1e-301030, to be precise).</p><p>So to test this properly, we&#39;re going to make sure that the filtering step is not the bottleneck, by first using our trusty <code>x -&gt; 2x</code> again and then &quot;filtering&quot; for only even numbers. This adds the additional filtering step, but doesn&#39;t let it fail, so the probability of getting an even number doesn&#39;t come into play and we can purely focus on the relative overhead to just <code>map</code>.</p><p>With PropCheck.jl, that leads to:</p><pre><code class="language-julia-repl hljs">julia&gt; evengen = PropCheck.vector(PropCheck.iconst(1_000_000), PropCheck.filter(iseven, PropCheck.map(x -&gt; 2x, PropCheck.itype(Int))));

julia&gt; @benchmark root(PropCheck.generate(evengen))
BenchmarkTools.Trial: 1 sample with 1 evaluation.
 Single result which took 8.756 s (21.85% GC) to evaluate,
 with a memory estimate of 9.63 GiB, over 45284301 allocations.</code></pre><p>Almost 9s - what a monster, and that&#39;s just for a single example! As for Supposition.jl..</p><pre><code class="language-julia-repl hljs">julia&gt; evengen = Data.Vectors(filter(iseven, map(x -&gt; 2x, Data.Integers{Int}())); min_size=1_000_000, max_size=1_000_000);

julia&gt; @benchmark example($evengen)
BenchmarkTools.Trial: 712 samples with 1 evaluation.
 Range (min … max):  5.594 ms … 29.914 ms  ┊ GC (min … max): 5.10% … 68.75%
 Time  (median):     6.672 ms              ┊ GC (median):    4.67%
 Time  (mean ± σ):   7.019 ms ±  2.362 ms  ┊ GC (mean ± σ):  9.82% ±  9.84%

   ▃█▄▅▅▃
  ███████▅▃▂▂▂▂▁▁▁▁▁▁▁▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▂▁▁▁▂▁▂▂▂▂ ▃
  5.59 ms        Histogram: frequency by time        21.2 ms &lt;

 Memory estimate: 25.04 MiB, allocs estimate: 34.</code></pre><p>Another factor 1000 timewise, and factor 200 memory wise!</p><h2 id="Shrinking"><a class="docs-heading-anchor" href="#Shrinking">Shrinking</a><a id="Shrinking-1"></a><a class="docs-heading-anchor-permalink" href="#Shrinking" title="Permalink"></a></h2><p>Generating values is only half the effort though; what about shrinking values to find a counterexample?</p><p>We&#39;re again going to use vectors of things as inputs, though we&#39;re going to use a slight modification. Shrinking is already pretty complicated, so we&#39;re going to look at much shorter inputs (only 1000 elements long), as well as hold their size constant. This way, only the elements of each collection will shrink, and neither framework can get &quot;lucky&quot; by only having to shrink short collections.</p><p>In order to prevent clobbering the output with unnecessary text, both PropCheck.jl and Supposition.jl are silenced through <code>redirect_*</code> and/or any switches they may provide themselves. This way, the resulting measurement should mostly be related to the shrinking itself, rather than any printing badness creeping in.</p><h3 id="Integers-2"><a class="docs-heading-anchor" href="#Integers-2">Integers</a><a class="docs-heading-anchor-permalink" href="#Integers-2" title="Permalink"></a></h3><p>Without further ado, here&#39;s PropCheck.jl:</p><pre><code class="language-julia-repl hljs">julia&gt; intgen = PropCheck.vector(PropCheck.iconst(1000), itype(Int));

julia&gt; @time check(isempty, intgen; show_initial=false)
[ Info: Found counterexample for &#39;isempty&#39;, beginning shrinking...
Internal error: during type inference of
iterate(Base.Iterators.ProductIterator{Tuple{Base.Generator{Array{Int64, 1}, Base.Fix1{typeof(PropCheck.unfold), Base.ComposedFunction{Type{PropCheck.Shuffle{T} where T}, typeof(PropCheck.shrink)}}}, Vararg{Array{PropCheck.Tree{Int64}, 1}, 999}}})
Encountered stack overflow.
This might be caused by recursion over very long tuples or argument lists.</code></pre><p>You&#39;ll notice that I&#39;m using <code>@time</code> here instead of <code>@benchmark</code>. The reason for this is pragmatic - I don&#39;t want to wait all day on PropCheck.jl. In this case though, the worry was completely unfounded, as the compiler can&#39;t handle the huge amount of nested functions this ends up generating. This result is, unfortunately, consistent for the following experiments. As such, I&#39;ll only show Supposition.jl.</p><p>Supposition.jl not only delivers a result, but does so in record time:</p><pre><code class="language-julia-repl hljs">julia&gt; intgen = Data.Vectors(Data.Integers{Int}(); min_size=1000, max_size=1000);

julia&gt; @time @check db=false isempty(intgen);
┌ Error: Property doesn&#39;t hold!
│   Description = &quot;isempty&quot;
│   Example = ([-9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808  …  -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808, -9223372036854775808],)
└ @ Supposition ~/Documents/projects/Supposition.jl/src/testset.jl:280
Test Summary: | Fail  Total
isempty       |    1      1
  0.404841 seconds (555.13 k allocations: 657.688 MiB, 5.12% gc time, 4.09% compilation time: 2% of which was recompilation)</code></pre><h3 id="Floats-2"><a class="docs-heading-anchor" href="#Floats-2">Floats</a><a class="docs-heading-anchor-permalink" href="#Floats-2" title="Permalink"></a></h3><p>Supposition.jl:</p><pre><code class="language-julia-repl hljs">julia&gt; floatgen = Data.Vectors(Data.Floats{Float64}(); min_size=1000, max_size=1000);

julia&gt; @time @check db=false isempty(floatgen);
┌ Error: Property doesn&#39;t hold!
│   Description = &quot;isempty&quot;
│   Example = ([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],)
└ @ Supposition ~/Documents/projects/Supposition.jl/src/testset.jl:280
Test Summary: | Fail  Total
isempty       |    1      1
  0.394480 seconds (535.17 k allocations: 656.722 MiB, 5.65% gc time, 1.20% compilation time: 5% of which was recompilation)</code></pre><h3 id="Strings-2"><a class="docs-heading-anchor" href="#Strings-2">Strings</a><a class="docs-heading-anchor-permalink" href="#Strings-2" title="Permalink"></a></h3><p>Supposition.jl:</p><pre><code class="language-julia-repl hljs">julia&gt; strgen = Data.Text(Data.Characters(); min_len=1000, max_len=1000);

julia&gt; @time @check db=false isempty(strgen);
┌ Error: Property doesn&#39;t hold!
│   Description = &quot;isempty&quot;
│   Example = (&quot;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;,)
└ @ Supposition ~/Documents/projects/Supposition.jl/src/testset.jl:280
Test Summary: | Fail  Total
isempty       |    1      1
  0.564029 seconds (548.62 k allocations: 592.570 MiB, 3.27% gc time, 0.77% compilation time: 4% of which was recompilation)</code></pre><h3 id="Map-2"><a class="docs-heading-anchor" href="#Map-2">Map</a><a class="docs-heading-anchor-permalink" href="#Map-2" title="Permalink"></a></h3><p>Supposition.jl:</p><pre><code class="language-julia-repl hljs">julia&gt; mapgen = Data.Vectors(map(x -&gt; 2x, Data.Integers{Int}()); min_size=1000, max_size=1000);

julia&gt; @time @check db=false isempty(mapgen);
┌ Error: Property doesn&#39;t hold!
│   Description = &quot;isempty&quot;
│   Example = ([0, 0, 0, 0, 0, 0, 0, 0, 0, 0  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0],)
└ @ Supposition ~/Documents/projects/Supposition.jl/src/testset.jl:280
Test Summary: | Fail  Total
isempty       |    1      1
  0.408549 seconds (557.02 k allocations: 657.772 MiB, 5.49% gc time, 4.99% compilation time: &lt;1% of which was recompilation)</code></pre><h3 id="Filter"><a class="docs-heading-anchor" href="#Filter">Filter</a><a id="Filter-1"></a><a class="docs-heading-anchor-permalink" href="#Filter" title="Permalink"></a></h3><p>Supposition.jl:</p><pre><code class="language-julia-repl hljs">julia&gt; oddgen = Data.Vectors(filter(isodd, map(x -&gt; 2x+1, Data.Integers{Int}())); min_size=1000, max_size=1000);

julia&gt; @time @check db=false isempty(oddgen);
┌ Error: Property doesn&#39;t hold!
│   Description = &quot;isempty&quot;
│   Example = ([1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  1, 1, 1, 1, 1, 1, 1, 1, 1, 1],)
└ @ Supposition ~/Documents/projects/Supposition.jl/src/testset.jl:280
Test Summary: | Fail  Total
isempty       |    1      1
  0.412517 seconds (562.41 k allocations: 658.063 MiB, 5.59% gc time, 4.44% compilation time: 2% of which was recompilation)</code></pre><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>If you&#39;ve read down to here, I don&#39;t think I even have to write it out - Supposition.jl is <em>fast</em>! I feel pretty confident saying that it&#39;s unlikely to be the bottleneck of a testsuite. All of that without even explicitly looking for places to optimize the package yet. Of course, this doesn&#39;t even touch cranking up the number of samples Supposition.jl tries, or any form of memoization on the property you could quite easily add. So there is potential for going faster in the future.</p><p>Go and incorporate fuzzing into your testsuite ;)</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="interfaces.html">« Userfacing API</a><a class="docs-footer-nextpage" href="api.html">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 21 March 2024 12:39">Thursday 21 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
