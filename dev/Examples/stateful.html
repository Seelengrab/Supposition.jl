<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stateful Testing · Supposition.jl Documentation</title><meta name="title" content="Stateful Testing · Supposition.jl Documentation"/><meta property="og:title" content="Stateful Testing · Supposition.jl Documentation"/><meta property="twitter:title" content="Stateful Testing · Supposition.jl Documentation"/><meta name="description" content="Documentation for Supposition.jl Documentation."/><meta property="og:description" content="Documentation for Supposition.jl Documentation."/><meta property="twitter:description" content="Documentation for Supposition.jl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Supposition.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Main Page</a></li><li><a class="tocitem" href="../intro.html">Introduction to PBT</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="basic.html">Basic Usage</a></li><li><a class="tocitem" href="composition.html">Composing Generators</a></li><li><a class="tocitem" href="recursive.html">Recursive Generation</a></li><li><a class="tocitem" href="docalignment.html">Alignment of Documentation</a></li><li><a class="tocitem" href="target.html">Targeted Operation</a></li><li class="is-active"><a class="tocitem" href="stateful.html">Stateful Testing</a><ul class="internal"><li><a class="tocitem" href="#Juggling-Jugs"><span>Juggling Jugs</span></a></li><li><a class="tocitem" href="#Balancing-a-heap"><span>Balancing a heap</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../resources.html">PBT Resources</a></li><li><a class="tocitem" href="../faq.html">FAQ</a></li><li><a class="tocitem" href="../interfaces.html">Userfacing API</a></li><li><a class="tocitem" href="../benchmarks.html">Benchmarks</a></li><li><a class="tocitem" href="../api.html">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="stateful.html">Stateful Testing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="stateful.html">Stateful Testing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Seelengrab/Supposition.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Seelengrab/Supposition.jl/blob/main/docs/src/Examples/stateful.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Stateful-Testing"><a class="docs-heading-anchor" href="#Stateful-Testing">Stateful Testing</a><a id="Stateful-Testing-1"></a><a class="docs-heading-anchor-permalink" href="#Stateful-Testing" title="Permalink"></a></h1><p>So far, we&#39;ve only seem examples of very simple &amp; trivial properties, doing little more than showcasing syntax. However, what if we&#39;re operating on some more complicated datastructure and want to check whether the operations we can perform on it uphold the invariants we expect? This too can, in a for now basic form, be done with Supposition.jl.</p><h2 id="Juggling-Jugs"><a class="docs-heading-anchor" href="#Juggling-Jugs">Juggling Jugs</a><a id="Juggling-Jugs-1"></a><a class="docs-heading-anchor-permalink" href="#Juggling-Jugs" title="Permalink"></a></h2><p>Consider this example from the movie Die Hard With A Vengeance:</p><p style="display: flex; justify-content: center;">
<iframe
  src="https://www.youtube-nocookie.com/embed/6cAbgAaEOVE"
  title="YouTube video player"
  frameborder="0"
  allow="picture-in-picture" allowfullscreen>
</iframe>
</p><p>The problem John McClane &amp; Zeus Carver have to solve is the well known 3L &amp; 5L variation on the <a href="https://en.wikipedia.org/wiki/Water_pouring_puzzle">water pouring puzzle</a>. You have two jugs, one that can hold 3L of liquid and one that can hold 5L. The task is to measure out <em>precisely</em> 4L of liquid, using nothing but those two jugs. Let&#39;s model the problem and have Supposition.jl solve it for us:</p><pre><code class="language-julia hljs">struct Jugs
    small::Int
    large::Int
end
Jugs() = Jugs(0,0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Jugs</code></pre><p>We start out with a struct holding our two jugs; one <code>Int</code> for the small jug and one <code>Int</code> for the large jug. Next, we need the operations we can perform on these jugs. These are</p><ul><li>Filling a jug to the brim<ul><li>No partial filling! That&#39;s not accurate enough.</li></ul></li><li>Emptying a jug<ul><li>No partial emptying! That&#39;s not accurate enough.</li></ul></li><li>Pouring one jug into the other<ul><li>Any leftover liquid stays in the jug we poured from - don&#39;t spill anything!</li></ul></li></ul><p>Defining them as functions returning a new <code>Jugs</code>, we get:</p><pre><code class="language-julia hljs"># filling
fill_small(j::Jugs) = Jugs(3, j.large)
fill_large(j::Jugs) = Jugs(j.small, 5)

# emptying
empty_small(j::Jugs) = Jugs(0, j.large)
empty_large(j::Jugs) = Jugs(j.small, 0)

# pouring
function pour_small_into_large(j::Jugs)
    nlarge = min(5, j.large + j.small)
    nsmall = j.small - (nlarge - j.large)
    Jugs(nsmall, nlarge)
end

function pour_large_into_small(j::Jugs)
    nsmall = min(3, j.small + j.large)
    nlarge = j.large - (nsmall - j.small)
    Jugs(nsmall, nlarge)
end</code></pre><p>From the top, we have filling either jug (note that we can only fill the small jug up to 3L, and the large up to 5L), emptying either jug, and finally pouring one into the other, taking care not to spill anything (i.e., any leftovers stay in the jug we poured out of).</p><p>We can very easily now generate a sequence of operations:</p><pre><code class="language-julia hljs">using Supposition

raw_ops = (fill_small, fill_large, empty_small, empty_large, pour_small_into_large, pour_large_into_small)
gen_ops = Data.Vectors(Data.SampledFrom(raw_ops))
example(gen_ops)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Function}:
 empty_large (generic function with 1 method)
 empty_small (generic function with 1 method)
 pour_large_into_small (generic function with 1 method)
 pour_large_into_small (generic function with 1 method)
 pour_small_into_large (generic function with 1 method)</code></pre><p>Generating a sequence of operations is simply generating a vector from all possible ones! This is the input to our property. We declare that for all sequences of operations we can do with a <code>Jug</code>, all invariants we expect must hold true.</p><p>Speaking of invariants, we need three of them that must be preserved at all times:</p><ol><li>The small jug must ALWAYS have a fill level between 0 and 3 (inclusive).</li><li>The large jug must ALWAYS have a fill level between 0 and 5 (inclusive).</li><li>The large just must NEVER have a fill level of exactly 4.</li></ol><p>The last invariant may look a bit odd, but remember that Supposition.jl is trying to find a <em>falsifying</em> example. The first two invariants are sanity checks to make sure that our pouring functions are well behaved; the last invariant is the solution we want to find, by combining the operations above in an arbitrary order. Let&#39;s translate these into functions as well:</p><pre><code class="language-julia hljs">small_jug_invariant(j::Jugs) = 0 &lt;= j.small &lt;= 3
large_jug_invariant(j::Jugs) = 0 &lt;= j.large &lt;= 5
level_invariant(j::Jugs) = j.large != 4
invariants = (small_jug_invariant, large_jug_invariant, level_invariant)</code></pre><p>And now, to finally combine all of these:</p><pre><code class="language-julia hljs">@check function solve_die_hard(ops = gen_ops)
    jugs = Jugs()

    for op in ops
        # apply the rule
        jugs = op(jugs)

        # check invariants
        for f in invariants
            f(jugs) || return false
        end
    end

    return true
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Error: Property doesn&#39;t hold!
│   Description = &quot;solve_die_hard&quot;
│   Example = (ops = Function[Main.fill_large, Main.pour_large_into_small, Main.empty_small, Main.pour_large_into_small, Main.fill_large, Main.pour_large_into_small],)
└ @ Supposition ~/work/Supposition.jl/Supposition.jl/src/testset.jl:280
Test Summary:  | Fail  Total  Time
solve_die_hard |    1      1  0.6s</code></pre><p>This pattern is very extensible, and a good candidate for the next UX overhaul (getting a reported failure for the target we actually want to find is quite bad UX). Nevertheless, it already works right now!</p><h2 id="Balancing-a-heap"><a class="docs-heading-anchor" href="#Balancing-a-heap">Balancing a heap</a><a id="Balancing-a-heap-1"></a><a class="docs-heading-anchor-permalink" href="#Balancing-a-heap" title="Permalink"></a></h2><p>The previous example showed how we can check these kinds of operations based invariants on an immutable struct. There is no reason why we can&#39;t do the same with a mutable struct (or at least, a struct containing a mutable object) though, so let&#39;s look at another example: ensuring a heap observes its heap property. As a quick reminder, the heap property for a binary heap is that each child of a node is <code>&lt;=</code> than that node, resulting in what&#39;s called a &quot;Max-Heap&quot; (due to the maximum being at the root). Similarly, if the property for children is <code>&gt;=</code>, we get a &quot;Min-Heap&quot;. Here, we&#39;re going to implement a Min-Heap.</p><p>First, we need to define our datastructure:</p><pre><code class="language-julia hljs">struct Heap{T}
    data::Vector{T}
end
Heap{T}() where T = Heap{T}(T[])</code></pre><p>as well as the usual operations (<code>isempty</code>, <code>push!</code>, <code>pop!</code>) on that heap:</p><ul><li><code>isempty</code>: Whether the heap has elements</li><li><code>push!</code>: Put an element onto the heap</li><li><code>pop!</code>: Retrieve the smallest element of the heap (i.e., remove the root)</li></ul><p>Written in code, this might look like this:</p><pre><code class="language-julia hljs">Base.isempty(heap::Heap) = isempty(heap.data)

function Base.push!(heap::Heap{T}, value::T) where T
    data = heap.data
    push!(data, value)
    index = lastindex(data)
    while index &gt; firstindex(data)
        parent = index &gt;&gt; 1
        if data[parent] &gt; data[index]
            data[parent], data[index] = data[index], data[parent]
            index = parent
        else
            break
        end
    end
    heap
end

Base.pop!(heap::Heap) = popfirst!(heap.data)</code></pre><p>In this implementation, we&#39;re simply using an array as the backing store for our heap. The first element is the root, followed by the left subtree, followed by the right subtree. As implemented, <code>pop!</code> will return the correct element if the heap is currently balanced, but because <code>pop!</code> doesn&#39;t rebalance the heap after removing the root, <code>pop!</code> may leave it in an invalid state. A subsequent <code>pop!</code> may then remove an element that is not the smallest currently stored.</p><p>We can very easily test this manually:</p><pre><code class="language-julia hljs">using Supposition

intvec = Data.Vectors(Data.Integers{UInt8}())

@check function test_pop_in_sorted_order(ls=intvec)
    h = Heap{eltype(ls)}()

    # push all items
    for l in ls
        push!(h, l)
    end

    # pop! all items
    r = eltype(ls)[]
    while !isempty(h)
        push!(r, pop!(h))
    end

    # the pop!ed items should be sorted
    r == sort(ls)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Error: Property doesn&#39;t hold!
│   Description = &quot;test_pop_in_sorted_order&quot;
│   Example = (ls = UInt8[0x00, 0x01, 0x00],)
└ @ Supposition ~/work/Supposition.jl/Supposition.jl/src/testset.jl:280
Test Summary:            | Fail  Total  Time
test_pop_in_sorted_order |    1      1  0.4s</code></pre><p>And as expected, the minimal counterexample is <code>[0x0, 0x1, 0x0]</code>. We first <code>pop!</code> <code>0x0</code>, followed by <code>0x1</code> while it should be <code>0x0</code> again, and only <em>then</em> <code>0x1</code>, resulting in <code>[0x0, 0x0, 0x1]</code> instead of <code>[0x0, 0x1, 0x0]</code>.</p><p>Replacing this with a (presumably) correct implementation looks like this:</p><pre><code class="language-julia hljs">function fixed_pop!(h::Heap)
    isempty(h) &amp;&amp; throw(ArgumentError(&quot;Heap is empty!&quot;))
    data = h.data
    isone(length(data)) &amp;&amp; return popfirst!(data)
    result = first(data)
    data[1] = pop!(data)
    index = 0
    while (index * 2 + 1) &lt; length(data)
        children = [ index*2+1, index*2+2 ]
        children = [ i for i in children if i &lt; length(data) ]
        @assert !isempty(children)
        sort!(children; by=x -&gt; data[x+1])
        broke = false
        for c in children
            if data[index+1] &gt; data[c+1]
                data[index+1], data[c+1] = data[c+1], data[index+1]
                index = c
                broke = true
                break
            end
        end
        !broke &amp;&amp; break
    end
    return result
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">fixed_pop! (generic function with 1 method)</code></pre><p>Me telling you that this is correct though should only be taken as well-intentioned, but not necessarily as true. There might be more bugs that have sneaked in after all, that aren&#39;t caught by our naive &quot;pop in order and check that it&#39;s sorted&quot; test. There could be a nasty bug waiting for us that only happens when various <code>push!</code> and <code>pop!</code> are interwoven in just the right way. Using stateful testing techniques and the insight that we can generate sequences of operations on our <code>Heap</code> with Supposition.jl too! We&#39;re first going to try with the existing, known broken <code>pop!</code>:</p><pre><code class="language-julia hljs">gen_push = map(Data.Integers{UInt}()) do i
    (push!, i)
end
gen_pop = Data.Just((pop!, nothing))
gen_ops = Data.Vectors(Data.OneOf(gen_push, gen_pop); max_size=10_000)</code></pre><p>We either <code>push!</code> an element, or we <code>pop!</code> from the heap. Using <code>(pop!, nothing)</code> here will make it a bit easier to actually define our test. Note how the second element acts as the eventual argument to <code>pop!</code>.</p><p>There&#39;s also an additional complication - because we don&#39;t have the guarantee anymore that the <code>Heap</code> contains elements, we have to guard the use of <code>pop!</code> behind a precondition check. In case the heap is empty, we can just consume the operation and treat it as a no-op, continuing with the next operation:</p><pre><code class="language-julia hljs">@check function test_heap(ops = gen_ops)
    heap = Heap{UInt}()

    for (op, val) in ops
        if op === push!
            # we can always push
            heap = op(heap, val)
        else
            # check our precondition!
            isempty(heap) &amp;&amp; continue

            # the popped minimum must always == the minimum
            # of the backing array, so retrieve the minimum
            # through alternative internals
            correct = minimum(heap.data)
            val = op(heap)

            # there&#39;s only one invariant this time around
            # and it only needs checking in this branch:
            val != correct &amp;&amp; return false
        end
    end

    # by default, we pass the test!
    # this happens if our `ops` is empty or all operations
    # worked successfully
    return true
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Error: Property doesn&#39;t hold!
│   Description = &quot;test_heap&quot;
│   Example = (ops = Union{Tuple{typeof(pop!), Nothing}, Tuple{typeof(push!), UInt64}}[(push!, 0x0000000000000001), (push!, 0x0000000000000000), (push!, 0x0000000000000000), (pop!, nothing), (pop!, nothing)],)
└ @ Supposition ~/work/Supposition.jl/Supposition.jl/src/testset.jl:280
Test Summary: | Fail  Total  Time
test_heap     |    1      1  0.2s</code></pre><p>Once again, we find our familiar example <code>UInt[0x0, 0x1, 0x0]</code>, though this time in the form of operations done on the heap:</p><pre><code class="language-julia hljs">ops = Union{Tuple{typeof(pop!), Nothing}, Tuple{typeof(push!), UInt64}}[
    (push!, 0x0000000000000001),
    (push!, 0x0000000000000000),
    (push!, 0x0000000000000000),
    (pop!, nothing),
    (pop!, nothing)
]</code></pre><p>We push three elements (0x1, 0x0 and 0x0) and when popping two, the second doesn&#39;t match the expected minimum anymore!</p><p>Now let&#39;s try the same property with our (hopefully correct) <code>fixed_pop!</code>:</p><pre><code class="language-julia hljs">gen_fixed_pop = Data.Just((fixed_pop!, nothing))
gen_fixed_ops = Data.Vectors(Data.OneOf(gen_push, gen_fixed_pop); max_size=10_000)

@check test_heap(gen_fixed_ops)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Test Summary: | Pass  Total   Time
test_heap     |    1      1  25.0s</code></pre><p>Now this is much more thorough testing!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="target.html">« Targeted Operation</a><a class="docs-footer-nextpage" href="../resources.html">PBT Resources »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Monday 4 March 2024 23:54">Monday 4 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
